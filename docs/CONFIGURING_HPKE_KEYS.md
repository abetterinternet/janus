# HPKE Keys

Janus, as part of implementing DAP, advertises HPKE keys via the `/hpke_configs`
endpoint. This document describes considerations for managing HPKE keys in a
Janus deployment.

## Key Rotator

It is strongly recommended to use the `key_rotator` component to manage HPKE key
provisioning and lifecycle.

### Separate process

The recommended method to run the key rotator is as a separate process alongside
the main aggregator processes.

Use the `key_rotator` subcommand of the `janus_aggregator` binary to invoke
the key rotator once. 
It can be invoked like so:
```
export DATASTORE_KEYS=[your database encryption key]
export PGPASSWORD=[your postgresql password here]
janus_aggregator key_rotator --config-file [path to configuration yaml]
```

where the configuration is like so:
```
database:
  url: "postgres://postgres:postgres@localhost:5432/postgres"

key_rotator:
  hpke: {}
```

This will create a single key and rotate it through a reasonable lifecycle. See
the [advanced sample](./samples/advanced_config/key_rotator.yaml) to see the
full set of configuration options and their default values.

Run this command on a cronjob, using your cron scheduling daemon of choice (e.g.
normal `cron`, systemd timers, Kubernetes CronJobs) on some reasonable cadence.

### In-process

A simpler, but less-recommended, way to run the key rotator is to run it as part
of the normal Janus aggregator.

In your aggregator configuration file, write.
```yaml
key_rotator:
  hpke: {}
```

Then restart the aggregator. This will create a single key and rotate it through
a reasonable lifecycle. See the [advanced
sample](./samples/advanced_config/aggregator.yaml) to see the full set of
configuration options and their default values.

Note that each aggregator replica will run the key rotator. This isn't harmful,
since the key rotator is safe to run concurrently, but it is wasteful. For high
scale deployments, run the [key rotator in a separate
process](#separate-process).

This is useful for Helper deployments that want a simple single-binary
deployment strategy.

## Key Lifecycle

An HPKE key is in one of three states:
- `pending`: The key is in the database, but is not yet being advertised to
  clients.
- `active`: The key is being advertised to clients, and clients should use it to
  encrypt reports.
- `expired`: The key is not advertised to clients, and will eventually be
  deleted.

These states are to facilitate key caching and rotation. The lifecycle of a key
is as follows:
1. The key is created in the `pending` state.
1. The in-memory caches of all Janus replicas must pick up the new key. This can
   be done by waiting or restarting the replicas.
1. The key is moved to the `active` state.
1. Caches must reload or the application can be restarted. The pending key
   already being in-memory ensures that replicas that haven't had their
   advertisement cache reloaded can still use the pending key to decrypt
   reports.
1. The key remains active for the key rotation interval.
1. When the key is due for expiry, a new key is introduced using the same steps
   as above.
1. The old key is moved to the `expired` state so that it's no longer advertised
   to clients. Because clients cache the HPKE advertisement, the key must still
   be available for report decryption.
1. For system integrity and availability, the expired key should not be deleted
   until after the last client report submitted before the key was expired has
   also expired.
   
## Manual Provisioning

### Aggregator API
A key can be manually generated by using the Janus aggregator API.

```bash
AGGREGATOR_URL=http://localhost:8081
AGGREGATOR_API_TOKEN="BASE64URL UNPADDED TOKEN HERE"

curl -v -X PUT \
    -H "Authorization: Bearer $AGGREGATOR_API_TOKEN" \
    -H "Accept: application/vnd.janus.aggregator+json;version=0.1" \
    -H "Content-Type: application/vnd.janus.aggregator+json;version=0.1" \
    "$AGGREGATOR_URL/hpke_configs" \
    --data '{}'
```

Example response:
```json
{
  "config": {
    "id": 1,
    "kem_id": "X25519HkdfSha256",
    "kdf_id": "HkdfSha256",
    "aead_id": "Aes128Gcm",
    "public_key": "Q6WsU8wTEYLGaSUZ0M64osfG67AfwZBxWvXp3lxIfxQ"
  },
  "state": "pending"
}
```

The keypair and ID will be generated for you, and stored in the database. If you
need to change the ciphers used, provide the `kem_id`, `kdf_id`, `aead_id`
parameters in the request body.

The key is created in the pending state. To move it into the active state:
```bash
KEY_ID=1

curl -v -X PATCH \
    -H "Authorization: Bearer $AGGREGATOR_API_TOKEN" \
    -H "Accept: application/vnd.janus.aggregator+json;version=0.1" \
    -H "Content-Type: application/vnd.janus.aggregator+json;version=0.1" \
    "$AGGREGATOR_URL/hpke_configs/$KEY_ID" \
    --data '{"state": "active"}'
```


This should return `200 OK` on success. If you need to mark it expired, change
the request body.

Other helpful methods are as follows:
- `GET /hpke_configs`: retrieve the details about all HPKE keys.
- `GET /hpke_configs/{:id}`: retrieve the details about a single key.
- `DELETE /hpke_configs/{:id}`: fully delete a key from the database; this is
  dangerous!

Note that the aggregator API will never directly expose the private key to you.
