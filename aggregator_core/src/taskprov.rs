use crate::{
    task::{self, Error, QueryType},
    SecretBytes,
};
use base64::{engine::general_purpose::URL_SAFE_NO_PAD, Engine};
use derivative::Derivative;
use janus_core::task::VdafInstance;
use janus_messages::{Duration, Role, TaskId, Time};
use lazy_static::lazy_static;
use rand::{distributions::Standard, prelude::Distribution};
use ring::hkdf::{KeyType, Salt, HKDF_SHA256};
use serde::{
    de::{self, Visitor},
    Deserialize, Serialize, Serializer,
};
use std::fmt;
use url::Url;

#[derive(Derivative, Clone, Copy, PartialEq, Eq)]
#[derivative(Debug)]
pub struct VerifyKeyInit(#[derivative(Debug = "ignore")] [u8; Self::LEN]);

impl VerifyKeyInit {
    pub const LEN: usize = 32;
}

impl TryFrom<&[u8]> for VerifyKeyInit {
    type Error = Error;

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        Ok(Self(value.try_into().map_err(|_| {
            Error::InvalidParameter("byte slice has incorrect length for VerifyKeyInit")
        })?))
    }
}

impl AsRef<[u8; Self::LEN]> for VerifyKeyInit {
    fn as_ref(&self) -> &[u8; Self::LEN] {
        &self.0
    }
}

impl Serialize for VerifyKeyInit {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let encoded = URL_SAFE_NO_PAD.encode(self.as_ref());
        serializer.serialize_str(&encoded)
    }
}

struct VerifyKeyInitVisitor;

impl<'de> Visitor<'de> for VerifyKeyInitVisitor {
    type Value = VerifyKeyInit;

    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {
        formatter.write_str("a base64url-encoded string")
    }

    fn visit_str<E>(self, value: &str) -> Result<VerifyKeyInit, E>
    where
        E: de::Error,
    {
        let decoded = URL_SAFE_NO_PAD
            .decode(value)
            .map_err(|_| E::custom("invalid base64url value"))?;
        VerifyKeyInit::try_from(decoded.as_ref()).map_err(|err| E::custom(err.to_string()))
    }
}

/// This customized implementation deserializes a [`VerifyKeyInit`] as a base64url-encoded string,
/// instead of as a byte array. This is more compact and ergonomic when serialized to YAML.
impl<'de> Deserialize<'de> for VerifyKeyInit {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_str(VerifyKeyInitVisitor)
    }
}

impl Distribution<VerifyKeyInit> for Standard {
    fn sample<R: rand::Rng + ?Sized>(&self, rng: &mut R) -> VerifyKeyInit {
        VerifyKeyInit(rng.gen())
    }
}

lazy_static! {
    /// Salt generated by the SHA256 of the string 'dap-taskprov". See [taskprov section 3.2][1].
    ///
    /// [1]: https://www.ietf.org/archive/id/draft-wang-ppm-dap-taskprov-04.html#name-deriving-the-vdaf-verificat
    static ref SALT: Salt = Salt::new(
        HKDF_SHA256,
        &[
            0x28, 0xb9, 0xbb, 0x4f, 0x62, 0x4f, 0x67, 0x9a, 0xc1, 0x98, 0xd9, 0x68, 0xf4, 0xb0,
            0x9e, 0xec, 0x74, 0x1, 0x7a, 0x52, 0xcb, 0x4c, 0xf6, 0x39, 0xfb, 0x83, 0xe0, 0x47,
            0x72, 0x3a, 0xf, 0xfe,
        ]
    );
}

impl VerifyKeyInit {
    /// Computes the VDAF verify key using the method defined in [draft-wang-ppm-dap-taskprov][1].
    ///
    /// [1]: https://www.ietf.org/archive/id/draft-wang-ppm-dap-taskprov-04.html#name-deriving-the-vdaf-verificat
    pub fn derive_vdaf_verify_key(
        &self,
        task_id: &TaskId,
        vdaf_instance: &VdafInstance,
    ) -> SecretBytes {
        let prk = SALT.extract(self.0.as_ref());
        let info = [task_id.as_ref().as_slice()];

        // Unwrap safety: this function only errors if the OKM length is too long
        // (<= 255 * HashLength). It is not expected that a VDAF's verify key length will ever
        // be _that_ long.
        let length = vdaf_instance.verify_key_length();
        let okm = prk.expand(&info, VdafVerifyKeyLength(length)).unwrap();

        let mut vdaf_verify_key = vec![0; length];
        // Same unwrap rationale as above.
        okm.fill(&mut vdaf_verify_key).unwrap();
        SecretBytes::new(vdaf_verify_key)
    }
}

/// Helper type for using `ring::Prk::expand()`.
struct VdafVerifyKeyLength(usize);

impl KeyType for VdafVerifyKeyLength {
    fn len(&self) -> usize {
        self.0
    }
}

/// Newtype for [`task::Task`], which omits certain fields that aren't required for taskprov tasks.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Task(pub(super) task::Task);

impl Task {
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        task_id: TaskId,
        aggregator_endpoints: Vec<Url>,
        query_type: QueryType,
        vdaf: VdafInstance,
        role: Role,
        vdaf_verify_keys: Vec<SecretBytes>,
        max_batch_query_count: u64,
        task_expiration: Option<Time>,
        report_expiry_age: Option<Duration>,
        min_batch_size: u64,
        time_precision: Duration,
        tolerable_clock_skew: Duration,
    ) -> Result<Self, Error> {
        let task = Self(task::Task::new_without_validation(
            task_id,
            aggregator_endpoints,
            query_type,
            vdaf,
            role,
            vdaf_verify_keys,
            max_batch_query_count,
            task_expiration,
            report_expiry_age,
            min_batch_size,
            time_precision,
            tolerable_clock_skew,
            None,
            Vec::new(),
            Vec::new(),
            Vec::new(),
        ));
        task.validate()?;
        Ok(task)
    }

    pub(super) fn validate(&self) -> Result<(), Error> {
        self.0.validate_common()?;
        if let QueryType::FixedSize {
            batch_time_window_size,
            ..
        } = self.0.query_type()
        {
            if batch_time_window_size.is_some() {
                return Err(Error::InvalidParameter(
                    "batch_time_window_size is not supported for taskprov",
                ));
            }
        }
        Ok(())
    }

    pub fn task(&self) -> &task::Task {
        &self.0
    }
}

impl From<Task> for task::Task {
    fn from(value: Task) -> Self {
        value.0
    }
}
